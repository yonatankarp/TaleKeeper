"""Export and sharing API endpoints."""

import base64
import io
import re
import smtplib
import zipfile
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from pathlib import Path

from fastapi import APIRouter, HTTPException
from fastapi.responses import Response, StreamingResponse
from pydantic import BaseModel

from talekeeper.db import get_db

router = APIRouter(tags=["exports"])


def _content_to_html(text: str) -> str:
    """Convert plain summary text to HTML paragraphs with divider support."""
    blocks = re.split(r"\n{2,}", text.strip())
    parts = []
    for block in blocks:
        stripped = block.strip()
        if re.fullmatch(r"[-]{3,}|[*]{3,}", stripped):
            parts.append('<div class="divider"></div>')
        else:
            parts.append(f"<p>{stripped}</p>")
    return "\n".join(parts)


async def _get_latest_session_image(session_id: int) -> bytes | None:
    """Return bytes of the most recent generated image for a session, or None."""
    async with get_db() as db:
        rows = await db.execute_fetchall(
            """SELECT file_path FROM session_images
               WHERE session_id = ? ORDER BY generated_at DESC LIMIT 1""",
            (session_id,),
        )
    if not rows:
        return None
    file_path = Path(rows[0]["file_path"])
    if not file_path.is_file():
        return None
    return file_path.read_bytes()


def _build_pdf_html(
    summary: dict,
    content_html: str,
    image_bytes: bytes | None,
    *,
    printable: bool = False,
) -> str:
    """Build the full D&D-themed HTML document for PDF export."""
    is_pov = summary["type"] == "pov"
    body_class = "pov" if is_pov else "full"

    if is_pov and summary.get("character_name"):
        title = f"The Journal of {summary['character_name']}"
        footer = f"As recorded by {summary.get('player_name', 'Unknown')}"
    else:
        title = "Session Chronicle"
        footer = "Generated by TaleKeeper"

    subtitle_parts = [
        summary.get("session_name") or "",
        summary.get("campaign_name") or "",
        summary.get("session_date") or "",
    ]
    subtitle = " &middot; ".join(p for p in subtitle_parts if p)

    hero_section = ""
    if image_bytes is not None:
        b64 = base64.b64encode(image_bytes).decode()
        hero_section = f'<img class="hero" src="data:image/png;base64,{b64}" />'

    if printable:
        page_bg = "background: #fff;"
        body_color = "color: #222;"
        border_color = "#999"
        accent_color = "#555"
        title_color = "#222"
    else:
        page_bg = "background: radial-gradient(ellipse at center, #f4e8d1 0%, #e8d5b0 100%);"
        body_color = "color: #2c1810;"
        border_color = "#8b7335"
        accent_color = "#8b7335"
        title_color = "#4a3520"

    return f"""<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Cinzel+Decorative:wght@700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap');

  @page {{
    size: A4;
    margin: 2cm;
    {page_bg}
  }}

  body {{
    font-family: 'Crimson Text', Georgia, serif;
    {body_color}
    line-height: 1.8;
    margin: 0;
    padding: 0;
  }}

  .wrapper {{
    border: 3px double {border_color};
    padding: 2rem 2.5rem;
    position: relative;
    box-shadow: inset 0 0 0 1px {border_color};
  }}

  .wrapper::before {{
    content: "\\2767";
    position: absolute;
    left: -1.5rem;
    top: 50%;
    transform: translateY(-50%);
    font-size: 1.5rem;
    color: {accent_color};
  }}

  .wrapper::after {{
    content: "\\2767";
    position: absolute;
    right: -1.5rem;
    top: 50%;
    transform: translateY(-50%) scaleX(-1);
    font-size: 1.5rem;
    color: {accent_color};
  }}

  .hero {{
    width: 100%;
    max-height: 300px;
    object-fit: cover;
    border-radius: 4px;
    margin-bottom: 1.5rem;
    border: 2px solid {border_color};
  }}

  h1 {{
    font-family: 'Cinzel', serif;
    font-weight: 700;
    font-size: 1.8rem;
    text-align: center;
    color: {title_color};
    margin: 0 0 0.25rem 0;
    letter-spacing: 0.05em;
  }}

  .subtitle {{
    font-family: 'Cinzel', serif;
    font-weight: 400;
    font-size: 0.85rem;
    text-align: center;
    color: {accent_color};
    margin-bottom: 1.5rem;
    letter-spacing: 0.08em;
  }}

  .ornament {{
    text-align: center;
    color: {accent_color};
    font-size: 1rem;
    margin: 0.5rem 0 1.5rem 0;
    letter-spacing: 0.3em;
  }}

  .content p {{
    text-indent: 1.5em;
    margin: 0 0 0.8em 0;
  }}

  .content p:first-of-type {{
    text-indent: 0;
  }}

  .content p:first-of-type::first-letter {{
    font-family: 'Cinzel Decorative', 'Cinzel', serif;
    font-weight: 700;
    font-size: 2.5em;
    line-height: 1;
    color: {title_color};
  }}

  .content .divider {{
    text-align: center;
    margin: 1.5em 0;
    color: {accent_color};
    font-size: 0.9rem;
    letter-spacing: 0.2em;
  }}

  .content .divider::before {{
    content: "\\2500\\2500\\2500 \\25C6 \\2500\\2500\\2500";
  }}

  .footer {{
    text-align: center;
    font-family: 'Cinzel', serif;
    font-size: 0.75rem;
    color: {accent_color};
    margin-top: 2rem;
    letter-spacing: 0.1em;
  }}

  .footer::before {{
    content: "\\269C  ";
  }}

  .footer::after {{
    content: "  \\269C";
  }}
</style>
</head>
<body class="{body_class}">
  <div class="wrapper">
    {hero_section}
    <h1>{title}</h1>
    <div class="subtitle">{subtitle}</div>
    <div class="ornament">&#9670;</div>
    <div class="content">
      {content_html}
    </div>
    <div class="footer">{footer}</div>
  </div>
</body>
</html>"""


async def _get_summary_with_meta(summary_id: int) -> dict:
    async with get_db() as db:
        rows = await db.execute_fetchall(
            """SELECT su.*, s.name as session_name, s.date as session_date,
                      c.name as campaign_name, sp.character_name, sp.player_name
               FROM summaries su
               JOIN sessions s ON s.id = su.session_id
               JOIN campaigns c ON c.id = s.campaign_id
               LEFT JOIN speakers sp ON sp.id = su.speaker_id
               WHERE su.id = ?""",
            (summary_id,),
        )
    if not rows:
        raise HTTPException(status_code=404, detail="Summary not found")
    return dict(rows[0])


def _build_title(summary: dict) -> str:
    if summary["type"] == "pov" and summary.get("character_name"):
        return f"The Journal of {summary['character_name']}"
    return "Session Chronicle"


def _build_meta(summary: dict) -> str:
    parts = [
        summary.get("session_name") or "",
        summary.get("campaign_name") or "",
        summary.get("session_date") or "",
    ]
    return " Â· ".join(p for p in parts if p)


@router.get("/api/summaries/{summary_id}/export/pdf")
async def export_pdf(summary_id: int, printable: bool = False) -> Response:
    from weasyprint import HTML

    summary = await _get_summary_with_meta(summary_id)
    image_bytes = await _get_latest_session_image(summary["session_id"])
    content_html = _content_to_html(summary["content"])
    html = _build_pdf_html(summary, content_html, image_bytes, printable=printable)

    pdf_bytes = HTML(string=html).write_pdf()

    title = _build_title(summary)
    filename = f"{title.replace(' ', '-').lower()}.pdf"
    return Response(
        content=pdf_bytes,
        media_type="application/pdf",
        headers={"Content-Disposition": f'attachment; filename="{filename}"'},
    )


@router.get("/api/summaries/{summary_id}/export/text")
async def export_text(summary_id: int) -> Response:
    summary = await _get_summary_with_meta(summary_id)

    title = _build_title(summary)
    meta = _build_meta(summary)
    text = f"{title}\n{'=' * len(title)}\n{meta}\n\n{summary['content']}"

    filename = f"{title.replace(' ', '-').lower()}.txt"
    return Response(
        content=text,
        media_type="text/plain",
        headers={"Content-Disposition": f'attachment; filename="{filename}"'},
    )


@router.get("/api/sessions/{session_id}/export/pov-all")
async def export_all_pov(session_id: int) -> StreamingResponse:
    from weasyprint import HTML

    async with get_db() as db:
        rows = await db.execute_fetchall(
            """SELECT su.*, s.name as session_name, s.date as session_date,
                      c.name as campaign_name, sp.character_name, sp.player_name
               FROM summaries su
               JOIN sessions s ON s.id = su.session_id
               JOIN campaigns c ON c.id = s.campaign_id
               LEFT JOIN speakers sp ON sp.id = su.speaker_id
               WHERE su.session_id = ? AND su.type = 'pov'""",
            (session_id,),
        )

    if not rows:
        raise HTTPException(status_code=404, detail="No POV summaries found")

    image_bytes = await _get_latest_session_image(session_id)

    buf = io.BytesIO()
    with zipfile.ZipFile(buf, "w", zipfile.ZIP_DEFLATED) as zf:
        for row in rows:
            summary = dict(row)
            content_html = _content_to_html(summary["content"])
            html = _build_pdf_html(summary, content_html, image_bytes)
            pdf_bytes = HTML(string=html).write_pdf()
            char_name = (summary.get("character_name") or "unknown").lower().replace(" ", "-")
            zf.writestr(f"{char_name}-pov.pdf", pdf_bytes)

    buf.seek(0)
    return StreamingResponse(
        buf,
        media_type="application/zip",
        headers={"Content-Disposition": 'attachment; filename="pov-summaries.zip"'},
    )


@router.get("/api/sessions/{session_id}/export/transcript")
async def export_transcript(session_id: int) -> Response:
    async with get_db() as db:
        session_rows = await db.execute_fetchall(
            """SELECT s.name, s.date, c.name as campaign_name
               FROM sessions s JOIN campaigns c ON c.id = s.campaign_id
               WHERE s.id = ?""",
            (session_id,),
        )
        if not session_rows:
            raise HTTPException(status_code=404, detail="Session not found")

        seg_rows = await db.execute_fetchall(
            """SELECT ts.text, ts.start_time, ts.end_time,
                      sp.player_name, sp.character_name
               FROM transcript_segments ts
               LEFT JOIN speakers sp ON sp.id = ts.speaker_id
               WHERE ts.session_id = ?
               ORDER BY ts.start_time""",
            (session_id,),
        )

    session = dict(session_rows[0])
    lines = [f"Transcript: {session['name']}", f"Campaign: {session['campaign_name']}", f"Date: {session['date']}", ""]

    for seg in seg_rows:
        s = dict(seg)
        h = int(s["start_time"] // 3600)
        m = int((s["start_time"] % 3600) // 60)
        sec = int(s["start_time"] % 60)
        time_str = f"{h:02d}:{m:02d}:{sec:02d}"

        speaker = ""
        if s.get("character_name") and s.get("player_name"):
            speaker = f" {s['character_name']} ({s['player_name']}):"
        elif s.get("character_name"):
            speaker = f" {s['character_name']}:"

        lines.append(f"[{time_str}]{speaker} {s['text']}")

    text = "\n".join(lines)
    return Response(
        content=text,
        media_type="text/plain",
        headers={"Content-Disposition": f'attachment; filename="transcript-{session_id}.txt"'},
    )


@router.get("/api/summaries/{summary_id}/email-content")
async def email_content(summary_id: int) -> dict:
    summary = await _get_summary_with_meta(summary_id)
    title = _build_title(summary)

    return {
        "subject": title,
        "body": summary["content"],
        "meta": _build_meta(summary),
    }


class SendEmailRequest(BaseModel):
    to: str


@router.post("/api/summaries/{summary_id}/send-email")
async def send_email(summary_id: int, body: SendEmailRequest) -> dict:
    summary = await _get_summary_with_meta(summary_id)
    title = _build_title(summary)

    # Get SMTP settings
    async with get_db() as db:
        settings_rows = await db.execute_fetchall("SELECT key, value FROM settings")
        settings = {r["key"]: r["value"] for r in settings_rows}

    smtp_host = settings.get("smtp_host")
    smtp_port = int(settings.get("smtp_port", "587"))
    smtp_user = settings.get("smtp_username")
    smtp_pass = settings.get("smtp_password")
    sender = settings.get("smtp_sender")

    if not all([smtp_host, smtp_user, smtp_pass, sender]):
        raise HTTPException(
            status_code=400,
            detail="Email not configured. Set SMTP settings in the Settings page.",
        )

    msg = MIMEMultipart()
    msg["From"] = sender
    msg["To"] = body.to
    msg["Subject"] = title
    msg.attach(MIMEText(summary["content"], "plain"))

    try:
        with smtplib.SMTP(smtp_host, smtp_port) as server:
            server.starttls()
            server.login(smtp_user, smtp_pass)
            server.send_message(msg)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to send email: {e}")

    return {"sent": True}
